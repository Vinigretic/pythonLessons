# Обьектно ориентированное программирование это - парадигма программирования, в которой основными концепциями являются
# понятия обьектов и классов
# Класс - является моделью еще не существующей сущности(обьекта). Он являеется составным типом данных, включающим в себя поля
# и методы.
# Обьект - это экземпляр класса
# Основные принципы ООП:
#     Абстракция -передает нашим обьктам только те характеристики, которые четко определяют его границы и которые четко отличают
# его от других обьектов. Описываем только те характеристики которые нас интересуют. Разделяет существенные детали реализации от
# несущественных которые нужны для коректного использования данных обьектов

#     Инкапсуляция - означает что наши обьекты могут в себе содержать разные данные и поведение обьедененные вместе, при этом
# какие-то из них являются публичными доступными для использования из вне, а дргуие являются деталами реализации и должны быть
# скрытими от доступа из вне
#     Инкапсуляция - это свойство системы, позволяющее обьединить данные и методы, работающие с ними, в классе и скрыть детали
#     реализации.
# (скрытие типов данных, скрытие членов класса, скрытие частей програмной системы)
# Инкапсуляция обеспечивается следующими средствами:
#     контроль доступа
#     методы доступа
#     своства обьекта

#     Полиморфизм - это????

#     Наследование - при наследовании классов, классы наследники получают все теже самые поведения и свойства которые были в базовых
# классах, но могут добавлять свои, либо переопределять старые. При наследовании новый класс является таким же как и старый, но при
# этом может имеет какие-то дополнения, либо изменения
#
# Класс составной полноценный тип данных. Составной потому что у него есть свои свойста и поведения
# Свойствами будут переменные которые будут находится внутри обьектов данного класса и поведение которое задается методами
# Методами будут функции которые будут пренадлежать обьектам данного класса и будут работать с его данными
# Класс описывает обьекты которые будут экземплярами данного класса описывет его поведение и свойства

# В Python все является обьектами(типы данных тоже обьекты) - экземплярами каких либо классов, даже сами классы, которые являются
# обьектами - экземплярами метаклассов. Главным метаклассом является класс type, который является абстракцией понятия типа данных

# class Myobject:         #класс описывает чем являются его обьекты, а не он сам
#     pass
# obj = Myobject()
# print(type(Myobject))
# print(type(obj)) # В Python определенное значение является значением определенного типа если оно является экземпляром данного класса

# Члены классов называются атрибутами. Атрибуты могут быть как переменными так и функциями.
# Классы потдерживают два вида операций - обращение к их атрибутам и создание обьектов - инцтанцирование.
# Обращение к атрибутам любого обьекта - указать имя обьекта, поставить точку указать имя атрибута.
# Для создания экземпляра(обьекта) класса используется синтаксис вызова функции

# Экземпляры классов в Python
# Единственная доступная операция для обьектов-экземпляров - это доступ к их атрибутам
# Атрибуты обьектов-экземпляров делятья на два типа: атрибуты-данные и методы
# Атрибуты-данные аналогичны полям, в терминологии большинства широко распространненых языков программирования
# Атрибуты-данные не нужно описывать, как и переменные они создаются в момент первого присваивания. Как правило их создают
# в метод-конструкторе __init__
# Метод - это функция принадлежащая обьекту. Все атрибуты класса, являющиеся функциями, описывают соответствующие методы
# его экземпляров, однако они не являются одним и тем же
# Особенностью методов является то, что в качестве первого аргумента им передается данный экземпляр класса. Таким образом,
# если obj - экземпляр класса MyClass, вызов метода obj.method() эквивалентен вызову функции MyClass.method(obj)

# class Myobject:  # создание класса
#     pass         # создаем пустой класс
# obj = Myobject()
# print(type(Myobject))
# print(type(obj))
# anotherclass = Myobject # создаем новый обьект который ссылается на тот же класс
# print(anotherclass)
# print(Myobject)

# СОЗДАНИЕ КЛАССОВ И ОБЛАСТЬ ВИДИМОСТИ ПЕРЕМЕННЫХ
# описываем класс в котором будет два атрибута класса
# class Myobject:
#     int_field = 8
#     str_field = 'a string'
# здесь же обьявляются функции с помощью def
# print(Myobject.int_field)
# print(Myobject.str_field)

# создаем два экземпляра данного класса(обекты), здесь у них еще нет своих данных
# object1 = Myobject()
# object2 = Myobject()
# через экземпляры класса мы так же можем получить доступ к атрибутам данного класса
# print(object1.int_field)
# print(object2.str_field)
# если пайтон не находит указанный атрибут среди атрибутов данных, он автоматически его ищет среди атриботов класса к которому
# пренадлежит объект
# изменим значение атрибута даного класса, при изменении атрибутa через класс, значение меняется для всех обьектов класса
# Myobject.int_field = 10
# print(Myobject.int_field)
# print(object1.int_field)
# изменим значение атрибута обратившись не через класс, а через обьект(экземпляр класса), в этом слчучае значение изменится только для обьекта
# object1.str_field = 'another string'  #фактически здесь мы создали экземпляр данных у конкретного экземпляра
# print(Myobject.str_field)
# print(object1.str_field)
# print(object2.str_field)

# Разница между атрибутами класса и атрибутами - данными
# Атрибуты класса являются общими для самого класса и всех его экземпляров.
# Их изменение отображается на все соответствующие обьекты.
# Атрибуды -данные принадлежат конкретному экземпляру и их изменение никак не влияет на соответствующие атрибуты
# других экземпляров данного класса. Таким образом артибуты класса, которые не являются функциями примерно соответствуют
# статическим полям в дугих языках программирования, а атрибуты-данные - обычным полям

# созданим и опишем новый класс человека
# так как у людей есть разные параметры они будут являться атрибудами-данными, а не атрибутами класса
# class Person:
#     def __init__(self, name, age): # метод конструктор
#         self.name = name
#         self.age = age
#     def print_info(self):  # self это первый параметр любого метода, ссылка на экземпляр текущего класса
#         print(self.name, 'is', self.age)

# создаем экземпляры класса(обьекты)
# john = Person()
# john.name = 'John'
# john.age = 22

# Lucy = Person()
# Lucy.name = 'Lucy'
# Lucy.age = 21

# для того что бы избежать лишних строк в коде, создания одинаковых атрибутов(в данном случае имя и возраст)
# подобные действия по инициализации обьекта помещаются в специальный метод конструктор __init__
# john = Person('John', 22)
# Lucy = Person('Lucy', 21)

# print(john.name, 'is', john.age) # здесь мы видим метод(вызов имени и возраста) который мы можем задать для наших двух обьектов
# print(Lucy.name, 'is', Lucy.age) # задаем его с помощью функции
# вызываем нашу функцию
# Person.print_info(john)
# Person.print_info(Lucy)
# любая функция - атрибут автоматически описывает метод, который будет находится внутри конкретного экземпляра класса
# и будет уже автоматически привязана к ниму, поэтому можем сделать следующее- обратится на прямую к методу конкретного обьекта
# john.print_info()
# Lucy.print_info()

# СТАТИЧЕСКИЕ МЕТОДЫ И МЕТОДЫ КЛАССА
# Декоратор - это спициальная функция, которая изменяет поведение функции или класса. Для применения декоратора следует перед
# соответсвующим обьявлением указать символ @, имя необходимого декоратора и список его аргументов в круглых скобках
# Если передача параметров декоратору не требуется, скобки не указываются
# Для создания статических методов используется декоратор staticmethod. Этот тип метода не принимает ни параметра self
# как метод экземпляра класса, ни параметра cls как метод класса. При этом, конечно, статический метод может принимать
# произвольное количество других параметров.
# Поэтому статический метод не может изменять ни состояние объекта, ни состояние класса. Статические методы ограничены
# в том, к каким данным они могут получить доступ.
#
# статический метод
# class Myobject:
#     class_attribute = 8 # атрибут класса
#     def __init__(self): # фукция конструктор
#         self.data_attribute = 42  # создает атрибут данных
# # описываем метод который будет возвращать нам атрубут данных data_attribute
#     def instance_method(self):
#         print(self.data_attribute)
# # описываем статический метод который будет работать на самом классе и всех его экземплярах
#     @staticmethod
#     def static_method():  # здесь нет доступа к атрибутам данных
#         print(Myobject.class_attribute)
# if __name__ == '__main__':  # если наш модуль был запущен как исполняемый файл(модуль кусок кода выше)
#     Myobject.static_method() # вызываем статический метод на классе
#     obj = Myobject() # создадим экземпляр данного класса
#     obj.instance_method() # вызовем его метод экземпляра класса
#     obj.static_method() # вызываем статический метод

# Методы класса
# Методы класса - привязаны к самому классу, а не к его обьектам и создаются с помощью декоратора classmethod.
# В качестве первого параметра принимают ссылку на обьект, обьектом выступает сам класс
# Методы класса похожи на обычные методы, но относятся к самому классу как обьекту - экземплера метакласса
# (в отличии от обычных методов,которые принадлежат обьектам - экземплярам классов и статических методов , которые относятся
# к самомму классу и всем его экземплярам и не принадлежат никакому обьекту - экземпляру). Их первый аргументы принято
# называть cls. В отличии от обычных методов не работают с экземплярами классов, не имеют доступа к атрибутам данных экземпляров
# классов. Т.е. это те же самые методы тоько привязанные к классам
# Это нужно для создания фабричных методов, перегрузок конструктора, альтеративных конструкторов и методов которые будут создавать
# экземпляры данного класса либо любого из его наследников если мы не знаем какой класс от нас требуется

# __repr__ -  метод который возвращает строковое представление объекта, который предназначен для внутреннего
#                 использования, отображается в отладчике или в интерактивной консол
# __str__ - метод который возвращает строковое представление объекта, но эту строку уже видит пользователь

# создадим класс прямоугольник, с методом конструктор который принимает как параметры две стороны
# class Rectangle:
#     def __init__(self, side_a, side_b):
#         self.side_a = side_a   # атрибуты данных
#         self.side_b = side_b
#
#     def __repr__(self):
#         return 'Rectangle(%.1f, %.1f)' % (self.side_a, self.side_b)
#
#
# class Circle:
#     def __init__(self, radius):
#         self.radius = radius
#
#     def __repr__(self):
#         return 'Circle(%.1f)' % (self.radius)
# # преобразуем прямоугольник в окружность, создав окружность которая описана вокруг прямоугольника
#
#     @classmethod                  # создаем классовый метод
#     def from_rectangle(cls, rectangle):  # который принимает прямоуголник
#         radius = (rectangle.side_a ** 2 + rectangle.side_b ** 2) ** 0.5 / 2 # вычесляем радиус по формуле
#         return cls(radius)
#
# def main():
#     rectangle = Rectangle(3, 4)
#     print(rectangle)
#
#     first_circle = Circle(1)
#     print(first_circle)
#
#     second_circle = Circle.from_rectangle(rectangle)
#     print(second_circle)
#
#
# if __name__ == '__main__':
#     main()

# ИНКАПСУЛЯЦИЯ
# Все атрибуты по умолчанию являются публичными.
# Атрибуты, имена которых начинаются с одного знака подчеркивания(_) говорят программисту о том, что они относятся ко
# внутренней реализации класса и не должны использоваться извне, однако никак не защищены.
# Атрибуты имена которых начинаются, но не заканчиваются  двумя символами подчеркивания,считаются приватными. К ним
# применяются механизм 'name mangling'. Он не предполагает защиты данных от изменений из вне, так как к ним все равно можно
# обратиться, зная имя класса и то как Python изменяет имена приватных атрибутов, однако позволяет защищать их от случайного
# переопределения в классах-потомках
# class Myobject:
#     def __init__(self):
#         self.__private_attribute = 42 # создаем в конструкторе приватный атрибут
#     def get_private(self):    # создаем метод который возвращает значение атрибута
#         return self.__private_attribute
# obj = Myobject() # создаю атрибут данного класса
# obj.get_private()  # получаем доступ к атрибуту
# print(obj.get_private())
# print(obj._Myobject__private_attribute) # обращение к атрибуду на прямую

# МЕТОДЫ ДОСТУПА И СВОЙСТВА ОБЬЕКТОВ
# Придставим что у нас есть какой-то класс и в нем есть приватный или защищенный атрибут и мы хотим сделать так что бы у нас был
# к нему какой то доступ, интерфейс для взаимодействия с ним.
# На примере - мы хотим что бы атрибут был доступен для чтения но не доступен для записи или мы могли записать в него значение, но
# значение должно автоматически проверяться на корректность
# Самый простой подход который здесь можно реализовать это описать специальные методы для установки или получения значения этого
# атрибута.
# У нас есть приватное поле и публичные методы и внутри этих методов могут находится любые доп действия
# Но более удобный механизм это механизм свойств
# Свойста это такие сущности которые выглядят для внешнего кода как поля?? но являются методами
# Объект.свойство = значение - вызывается метод для установки данного значения

# class Myobject:
#     def __init__(self):
#         self.__private_attribute = 10 # создаем в конструкторе приватный атрибут
#
#     def get_attribute(self):    # создаем метод который возвращает значение атрибута
#         return self.__private_attribute
#
#     def set_attribute(self, value):
#         if value < 100:
#             self.__private_attribute = value
#
# obj = Myobject()
# obj.get_attribute()
# print(obj.get_attribute())
# obj.set_attribute(30)
# print(obj.get_attribute())

# тоже самое но только с помощью свойств

class Myobject:
    def __init__(self):
        self.__attribute = 0
# описываем свойства
    @property
    def attribute(self):
        return self.__attribute
# описываем метод который будет завать нам знечения для данного свойства
    @attribute.setter  #имя метода выше
    def attribute(self, value):
        if value < 100:
            self.__attribute = value

obj = Myobject()
obj.attribute
print(obj.attribute)
obj.attribute = 20
print(obj.attribute)